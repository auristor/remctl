TODO:

- forwardable tickets?
- [aclfile]+
- anyuser



DOCUMENT:
host@server or service/type are different gssapi types:
gss_nt_service_name              gss_nt_user_name


The new K5 sysctl design plan.

Preliminary new name: remctl (like remote control)

Purpose is to allow an authenticated and authorized service of
remotely executing a preset command with arbitrary arguments. The
commands are not passed to be executed in the shell, instead a type
and service are specified which map to a predefined executable on
the server. The rest of the arguments are passed to that predefined
command. Only one command is allowed per a transaction, with one
response.

Written in C, the GSS-API K5 auth will be used - it's a language
independednt standard that's more general, easier to code and debug
then straight K5.

Client
=======

Auth
----

Client connects and authenticates using tokens from gssapi calls.
Format of all tokens is the same, including request and response
tokens.

flags          - 1 byte
length of data - 4 bytes
data           - <length of data>

The authentication transfer sequence is finalized by an empty token.
Unauthenticated connection are denied.

Flags are for signifying the stage in communication, such as
"establishing authentication context", "end of tokens", "request
token", "response token", or "error token".

Request
-------

Client accepts command line arguments:
<client specific switches> type service arg1 .. argN
Client gets the arguments in argv format: array of strings.

Client passes the arguments packed into a data payload section of a
token. Its format is a sequence of lendth and argument fields,
packed in for the length of the data field.

length of argument - 4 bytes
argument           - <length of data>


Response
--------

Client waits for a response which is expected in the same token
format. The flags for a response can be "response" and "error".

In case of positive response, the data takes on this format:
length of return message - 4 bytes
return message           - <length of data>

In the error case:
error code              - 4 bytes
length of error message - 4 bytes
error message           - <length of data>



Server
========

The server will need to support multiprocessing to accomodate several
incoming connections at a time. However in using tcpserver or inetd,
there is the overhead of reading/parsing the conf file on every
request and the somewhat tricky mecanism of importing a gssapi context
(so as to not recreate it everytime). The initial version is proposed
to do internal socket programming, to avoid these difficulties.

Upon startup Server reads the conf file. Its format per line:
type service command aclfile

type - specifies the "domain" of commands, like ss (service server -
       the srvtab generation stuff) or cgi (for approval and creation
       of cgi accounts).

service - a particular service within the type. If the entire type is
          granted, the keyword "all" can be used,

command - path and filename of a program to execute as part of the
          request.

aclfile - a file containing a list of identities, one per line, of
          those authorized to request this service.

Both the conf file and aclfiles allow empty lines and comments that
start with a '#' character.


Request
-------

A description of the authentication process and the token format is
provided in the Client section above. Each request gets forked off,
to allow for simultaneous requests.


Response
--------

The process is forked when it's time to exec the command, a pipe is
used to collect the output and the parent wait()'s for the status
from the child.

If the return status represents an error, a "error" token is sent
back, otherwise a regular data token is sent.




-anton


