import org.ietf.jgss.*;
import java.net.Socket;
import java.io.IOException;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.nio.ByteBuffer;


public class RemctlClient {

    static int MAXBUFFER = 64000;
    /* Token types */
    static int TOKEN_NOOP  =            (1<<0);
    static int TOKEN_CONTEXT =          (1<<1);
    static int TOKEN_DATA =             (1<<2);
    static int TOKEN_MIC =              (1<<3);

    /* Token flags */
    static int TOKEN_CONTEXT_NEXT =     (1<<4);
    static int TOKEN_SEND_MIC =         (1<<5);

    public String clientIdentity;
    public String serverIdentity;
    public int    returnCode;
    public String returnMessage;

    GSSContext context;
    MessageProp prop;
    Socket socket;
    DataInputStream inStream;
    DataOutputStream outStream;
    ByteBuffer messageBuffer;
    String hostName;
    String servicePrincipal;
    int port;

    public RemctlClient(String host, String service, int portNumber) {
	hostName = host;
	servicePrincipal = service;
	port = portNumber;

	messageBuffer = ByteBuffer.allocate(MAXBUFFER);
    }

    public RemctlClient(String host) {
	hostName = host;
	messageBuffer = ByteBuffer.allocate(MAXBUFFER);
    }

    public static void main(String[] args) throws Exception  {

	// Obtain the command-line arguments and parse the port number
	
	if (args.length < 3) {
	    System.err.println("Usage: java <options> Login SampleClient "
			       + " <hostName> <type> <service> <args>");
	    System.exit(-1);
	}

	String thisHostName = args[0];
	String servicePrincipal = "host/"+thisHostName+".stanford.edu";

	RemctlClient thisClient = new RemctlClient(args[0], 
						   servicePrincipal, 4444);
	String remargs[] = new String[args.length-1];
	for(int i=1; i<args.length; i++)
	    remargs[i-1] = args[i];

	thisClient.process(remargs);

	if (thisClient.returnCode != 0)
	    System.out.println("Error code: "+thisClient.returnCode);

	System.out.println(thisClient.returnMessage);

    }

    public void process(String args[])  throws GSSException, IOException, RemctlException {

	/* Make the socket: */
	socket =    new Socket(hostName, port);
	inStream =  new DataInputStream(socket.getInputStream());
	outStream = new DataOutputStream(socket.getOutputStream());

	clientEstablishContext();
	processRequest(args);
	processResponse();

	context.dispose();
	socket.close();
    }

    private void clientEstablishContext() throws GSSException, IOException, RemctlException {

	/*
	 * This Oid is used to represent the Kerberos version 5 GSS-API
	 * mechanism. It is defined in RFC 1964. We will use this Oid
	 * whenever we need to indicate to the GSS-API that it must
	 * use Kerberos for some purpose.
	 */
	Oid krb5Oid = new Oid("1.2.840.113554.1.2.2");

	GSSManager manager = GSSManager.getInstance();

	/*
	 * Create a GSSName out of the service name. The null
	 * indicates that this application does not wish to make
	 * any claims about the syntax of this name and that the
	 * underlying mechanism should try to parse it as per whatever
	 * default syntax it chooses.
	 */
	GSSName serverName = manager.createName(servicePrincipal, null);

	/*
	 * Create a GSSContext for mutual authentication with the
	 * server.
	 *    - serverName is the GSSName that represents the server.
	 *    - krb5Oid is the Oid that represents the mechanism to
	 *      use. The client chooses the mechanism to use.
	 *    - null is passed in for client credentials
	 *    - DEFAULT_LIFETIME lets the mechanism decide how long the
	 *      context can remain valid.
	 * Note: Passing in null for the credentials asks GSS-API to
	 * use the default credentials. This means that the mechanism
	 * will look among the credentials stored in the current Subject
	 * to find the right kind of credentials that it needs.
	 */
	context = manager.createContext(serverName,
					krb5Oid,
					null,
					GSSContext.DEFAULT_LIFETIME);

	// Set the optional features on the context.
	context.requestMutualAuth(true);  // Mutual authentication
	context.requestConf(true);  // Will use confidentiality later
	context.requestInteg(true); // Will use integrity later


	byte[] token = new byte[0];
	returnCode = 0;

	// Initialize the context establishment 
	outStream.writeByte(TOKEN_NOOP|TOKEN_CONTEXT_NEXT);
	outStream.writeInt(token.length);
	outStream.write(token);
	outStream.flush();

	// Do the context establishment loop
	while (!context.isEstablished()) {

	    // token is ignored on the first call
	    token = context.initSecContext(token, 0, token.length);

	    // Send a token to the server if one was generated by
	    // initSecContext
	    if (token != null) {
                outStream.writeByte(TOKEN_CONTEXT);
		outStream.writeInt(token.length);
		outStream.write(token);
		outStream.flush();
	    }

	    // If the client is done with context establishment
	    // then there will be no more tokens to read in this loop
	    if (!context.isEstablished()) {
		inStream.readByte(); // flag
		token = new byte[inStream.readInt()];
		inStream.readFully(token);
	    }
	}
	
	clientIdentity = context.getSrcName().toString();
	serverIdentity = context.getTargName().toString();

	/*
	 * If mutual authentication did not take place, then only the
	 * client was authenticated to the server. Otherwise, both
	 * client and server were authenticated to each other.
	 */
	if (! context.getMutualAuthState()) {
	    throw new RemctlException("Mutual authentication did not took place!");
	}

    }


    private void processRequest(String args[])  throws GSSException, IOException, RemctlException {

	/* Make the message buffer */
	messageBuffer.putInt(args.length);
	for(int i=0;i<args.length;i++) {
	    messageBuffer.putInt(args[i].length());
	    messageBuffer.put(args[i].getBytes());
	}

	/* Extract the raw bytes of the message */
	int length = messageBuffer.position();
	messageBuffer.rewind();
	byte[] messageBytes = new byte[length];
	messageBuffer.get(messageBytes);
	
	/*
	 * The first MessageProp argument is 0 to request
	 * the default Quality-of-Protection.
	 * The second argument is true to request
	 * privacy (encryption of the message).
	 */
	prop =  new MessageProp(0, true);

	/*
	 * Encrypt the data and send it across. Integrity protection
	 * is always applied, irrespective of confidentiality
	 * (i.e., encryption).
	 * You can use the same token (byte array) as that used when 
	 * establishing the context.
	 */

	byte[] token = context.wrap(messageBytes, 0, messageBytes.length, prop);
	outStream.writeByte(TOKEN_DATA | TOKEN_SEND_MIC);
	outStream.writeInt(token.length);
	outStream.write(token);
	outStream.flush();

	/*
	 * Now we will allow the server to decrypt the message,
	 * calculate a MIC on the decrypted message and send it back
	 * to us for verification. This is unnecessary, but done here
	 * for illustration.
	 */
	inStream.readByte(); // flag
	token = new byte[inStream.readInt()];
	inStream.readFully(token);
	context.verifyMIC(token, 0, token.length, 
			  messageBytes, 0, messageBytes.length,
			  prop);
	
    }


    private void processResponse() throws GSSException, IOException, RemctlException {

  	byte flag = inStream.readByte();

	if ((flag & TOKEN_DATA) == 0) {
	    throw new RemctlException("Wrong token type received, expected TOKEN_DATA");
	}

	byte[] token = new byte[inStream.readInt()];
	inStream.readFully(token);

	byte[] bytes = context.unwrap(token, 0, token.length, prop);
	messageBuffer = ByteBuffer.allocate(bytes.length);
	messageBuffer.put(bytes);
	messageBuffer.rewind();

	returnCode = messageBuffer.getInt();

	byte[] responsebytes = new byte[messageBuffer.getInt()];
	messageBuffer.get(responsebytes);

	returnMessage = new String(responsebytes);

	/*
	 * First reset the QOP of the MessageProp to 0
	 * to ensure the default Quality-of-Protection
	 * is applied.
	 */
	prop.setQOP(0);
    
	token = context.getMIC(bytes, 0, bytes.length, prop);
    
	outStream.writeByte(TOKEN_MIC);
	outStream.writeInt(token.length);
	outStream.write(token);
	outStream.flush();
    
    }
}
