#!/usr/bin/perl -w
#
# Tests for the Net::Remctl API.  This relies on being run as part of the
# larger remctl build tree and uses the built remctld for testing.
#
# Written by Russ Allbery <rra@stanford.edu>
# Copyright 2007, 2008, 2009, 2011
#     The Board of Trustees of the Leland Stanford Junior University
#
# See LICENSE for licensing terms.

BEGIN { our $total = 45 }
use Test::More tests => $total;

use Net::Remctl;

# Returns the principal to use for authentication.
sub get_principal {
    open (PRINC, 'config/principal') or return;
    my $princ = <PRINC>;
    close PRINC;
    chomp $princ;
    return $princ;
}

# Do the bizarre dance to start a test version of remctld.
sub start_remctld {
    unlink ('tmp/pid');
    mkdir 'tmp';
    my $princ = get_principal;
    my $pid = fork;
    if (not defined $pid) {
        die "cannot fork: $!\n";
    } elsif ($pid == 0) {
        chdir ('@abs_top_srcdir@/tests')
            or die "can't chdir to @abs_top_srcdir@: $!\n";
        exec ('@abs_top_builddir@/server/remctld', '-m', '-p', '14373',
              (defined ($princ) ? ('-s', $princ) : ()),
              '-P', '@abs_top_builddir@/tests/tmp/pid',
              '-f', 'data/conf-simple',
              '-d', '-S', '-F', '-k',
              '@abs_top_builddir@/tests/config/keytab')
            or die "cannot exec @abs_top_builddir@/server/remctld: $!\n";
    }
}

# Stop the running test remctld.
sub stop_remctld {
    if (open (PID, 'tmp/pid')) {
        my $pid = <PID>;
        chomp $pid;
        kill (15, $pid);
        unlink 'tmp/pid';
        rmdir 'tmp';
    }
}

# Obtain tickets, which requires iterating through several different possible
# ways of running kinit.
sub run_kinit {
    $ENV{KRB5CCNAME} = 'tmp/krb5cc_test';
    my $princ = get_principal;
    return unless $princ;
    my @commands = ([ qw(kinit --no-afslog -k -t config/keytab), $princ ],
                    [ qw(kinit -k -t config/keytab), $princ ],
                    [ qw(kinit -t config/keytab), $princ ],
                    [ qw(kinit -k -K config/keytab), $princ ]);
    my $status;
    for (@commands) {
        $status = system "@$_ > /dev/null < /dev/null";
        if ($status == 0) {
            return 1;
        }
    }
    warn "Unable to obtain Kerberos tickets\n";
    unless (-f 'tmp/pid') {
        sleep 1;
    }
    stop_remctld;
    return;
}

# Test setup.
chdir '@abs_top_builddir@/tests';
my $okay = (-f 'config/principal' && -f 'config/keytab');
if ($okay) {
    start_remctld;
    $okay = run_kinit;
}
SKIP: {
    skip "no Kerberos configuration", $total unless $okay;

    sleep 1 unless -f 'tmp/pid';
    die "remctld did not start" unless -f 'tmp/pid';

    # Now we can finally run our tests.  Basic interface, success.
    my $principal = get_principal;
    my $result = remctl ('localhost', 14373, $principal, 'test', 'test');
    isa_ok ($result, 'Net::Remctl::Result', 'Basic remctl return');
    is ($result->status, 0, '... exit status');
    is ($result->stdout, "hello world\n", '... stdout output');
    is ($result->stderr, undef, '... stderr output');
    is ($result->error, undef, '... error return');

    # Basic interface, failure.
    $result = remctl ('localhost', 14373, $principal, 'test', 'bad-command');
    isa_ok ($result, 'Net::Remctl::Result', 'Error remctl return');
    is ($result->status, 0, '... exit status');
    is ($result->stdout, undef, '... stdout output');
    is ($result->stderr, undef, '... stderr output');
    is ($result->error, 'Unknown command', '... error return');

    # Complex interface, success.
    my $remctl = Net::Remctl->new;
    isa_ok ($remctl, 'Net::Remctl', 'Object');
    is ($remctl->error, 'no error', '... no error set');
    ok ($remctl->open ('localhost', 14373, $principal), 'Connect to server');
    is ($remctl->error, 'no error', '... no error set');
    ok ($remctl->noop, 'Send NOOP message');
    is ($remctl->error, 'no error', '... no error set');
    ok ($remctl->command ('test', 'test'), 'Send successful command');
    is ($remctl->error, 'no error', '... no error set');
    my $output = $remctl->output;
    isa_ok ($output, 'Net::Remctl::Output', 'Output token');
    is ($output->type, 'output', '... of type output');
    is ($output->length, 12, '... and length 12');
    is ($output->data, "hello world\n", '... with the right data');
    is ($output->stream, 1, '... and the right stream');
    $output = $remctl->output;
    isa_ok ($output, 'Net::Remctl::Output', 'Second output token');
    is ($output->type, 'status', '... of type status');
    is ($output->status, 0, '... with status 0');

    # Complex interface, failure.
    ok ($remctl->command ('test', 'bad-command'), 'Send failing command');
    is ($remctl->error, 'no error', '... no error set');
    $output = $remctl->output;
    isa_ok ($output, 'Net::Remctl::Output', 'Output token');
    is ($output->type, 'error', '... of type error');
    is ($output->data, 'Unknown command', '... with the error message');
    is ($output->error, 5, '... and the right code');

    # Complex interface with source IP.
    $remctl = Net::Remctl->new;
    isa_ok ($remctl, 'Net::Remctl', 'Object');
    is ($remctl->error, 'no error', '... no error set');
    is ($remctl->set_source_ip ('127.0.0.1'), 1, 'Set source IP');
    is ($remctl->error, 'no error', '... no error set');
    ok ($remctl->open ('127.0.0.1', 14373, $principal), 'Connect to server');
    is ($remctl->error, 'no error', '... no error set');

    # Complex interface with unworkable source IP.
    is ($remctl->set_source_ip ('::1'), 1, 'Set source IP to ::1');
    is ($remctl->error, 'no error', '... no error set');
    ok (!$remctl->open ('127.0.0.1', 14373, $principal),
        'Cannot connect to server');
    like ($remctl->error, qr/^(cannot connect to|unknown host) /,
          '... with correct error');

    # Get the current ticket cache location and then change KRB5CCNAME.
    # Connecting should then fail since we have no ticket cache.
    my $cache = $ENV{KRB5CCNAME};
    $ENV{KRB5CCNAME} = './nonexistent-file';
    $remctl = Net::Remctl->new;
    isa_ok ($remctl, 'Net::Remctl', 'Object');
    ok (!$remctl->open ('localhost', 14373, $principal),
        'Cannot connect without cache');

    # Set the ticket cache, and then open should work.
  SKIP: {
        skip 'gss_krb5_set_ccache not supported', 1
            unless $remctl->set_ccache ($cache);
        ok ($remctl->open ('localhost', 14373, $principal),
            'Connect now works');
    }

    # Remove our ticket cache; we're done.
    unlink $cache;
}

END {
    stop_remctld;
}
